学习笔记 - Week_09

------

  **第9周 | 第19课 高级动态规划**

  回顾基础动态规划：

  1.动态规划复习；附带递归（函数自己调用自己）、分治；

​     递归、分治、回溯没有根本的区别，就是定义一个问题的不同的方面
​     递归模板：

```
public void recur(int level,int param) {  //terminator
  if(level > maxLevel) {     //process result
     return;   }
   
  //process current logic
  process(level,param);

   //drill dowm  recur(level + 1,newParam);
  //restore current status
}
```


  分治：归并排序就是一个典型的分治解法

  斐波那契数列 -> 递归树 -> 记忆化缓存 -> **动态规划（分治 + 最优子结构）**：

​    1.将复杂问题分解为一个简单的子问题（也是一种分治的思想）
​     2.最优子结构
​     3.顺推形式：动态递推

  2.多种情况的动态规划的状态转移方程串讲

​     dp状态的定义最复杂，需要一定的经验。将现实的问题抽象成一个数组，里面保存状态。 状态转移方程也是个难点。

​     爬楼梯问题：Fib问题、硬币置换问题都有异曲同工之处。 最基本的解法2^n，加记忆化搜索O(n)、递归转顺推O（n）、内存进一步优化O(n)、O(1)

​     不同路径：无障碍、有障碍

​     打家劫舍：如何从二维转一维再转成三个变量式的递推，逐步理解，优化。

​     **最小路径和 - 64**：dp[i][j] 状态的定义：minPath(A[1 -> i][1 -> j])          dp[i][j] = min(dp[i - 1][j],dp[i][j - 1] + A[i][j])

​     股票买卖系列：好好看题解
​     

  3.进阶版动态规划的习题



  **第9周 第20课 | 字符串算法**  

string java 中是 immutable（不可变） 的。 好处是，线程安全的。